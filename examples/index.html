<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="/lib/codemirror.css">
<link rel="stylesheet" href="snomedct_cg.css">
<script src="/lib/codemirror.js"></script>
<script src="addon/mode/simple.js"></script>
<script src="/channel/bcsocket.js"></script>
<script src="/share.js"></script>
<script src="/share-codemirror.js"></script>
<script src="/node_modules/jquery/dist/jquery.min.js"></script>
</head>
<body>
	<textarea id="pad">Connecting...</textarea>
	<a href="javascript:autoFormatSelection()"> Autoformat Selected </a>
	&nbsp;
	<a href="javascript:checkSyntax()"> Check Syntax </a>
	&nbsp;
	<a href="javascript:diagram()"> Diagram </a>
	<div id="message"></div>
	<div id="diagram"></div>
	<script type="text/javascript">
/* Example definition of a simple mode that understands a subset of
 * JavaScript:
 */

CodeMirror.defineExtension("autoFormatRange", function (from, to) {

    console.log("autoFormatRange");
    var cm = this;
    var outer = cm.getMode(), text = cm.getRange(from, to).split("\n");
    var state = CodeMirror.copyState(outer, cm.getTokenAt(from).state);
    var tabSize = cm.getOption("tabSize");

    var out = "", lines = 0, atSol = from.ch == 0;
    function newline() {
        out += "\n";
        atSol = true;
        ++lines;
    }

    for (var i = 0; i < text.length; ++i) {
        var stream = new CodeMirror.StringStream(text[i], tabSize);
        while (!stream.eol()) {
            var inner = CodeMirror.innerMode(outer, state);
            var style = outer.token(stream, state), cur = stream.current();
            stream.start = stream.pos;
            if (!atSol || /\S/.test(cur)) {
                out += cur;
                atSol = false;
            }
            if (!atSol && inner.mode.newlineAfterToken &&
                inner.mode.newlineAfterToken(style, cur, stream.string.slice(stream.pos) || text[i+1] || "", inner.state))
                newline();
        }
        if (!stream.pos && outer.blankLine) outer.blankLine(state);
        if (!atSol) newline();
    }

    cm.operation(function () {
        cm.replaceRange(out, from, to);
        for (var cur = from.line + 1, end = from.line + lines; cur <= end; ++cur)
            cm.indentLine(cur, "smart");
        cm.setSelection(from, cm.getCursor(false));
    });
});

// Applies automatic mode-aware indentation to the specified range
CodeMirror.defineExtension("autoIndentRange", function (from, to) {
    var cmInstance = this;
    this.operation(function () {
        for (var i = from.line; i <= to.line; i++) {
            cmInstance.indentLine(i, "smart");
        }
    });
});

CodeMirror.defineSimpleMode("simplemode", {
  // The start state contains the rules that are intially used
  start: [
    // The regex matches the token, the token property contains the type
    // {regex: /\|(?:[^\\]|\\.)*?\|/, token: "def"},
    {regex: /(?:\.\d+|\d+\.?\d*)(?:e[-+]?\d+)?/i,
     token: "number"},
    // A next property will cause the mode to move to a different state
    {regex: /\|/, token: "operator", next: "descr"},
    {regex: /\=\(/, token: "operator", indent: true},
    {regex: /[+=]+/, token: "operator"},
    // indent and dedent properties guide autoindentation
    {regex: /[\:\{\(]/, indent: true},
    {regex: /[\}\)]/, dedent: true},
  ],
  // The multi-line comment state.
  descr: [
    {regex: /\|/, token: "operator", next: "start"},
    {regex: /[^|]*/, token: "description"}
  ],
  // The meta property contains global information about the mode. It
  // can contain properties like lineComment, which are supported by
  // all modes, and also directives like dontIndentStates, which are
  // specific to simple modes.
  meta: {
    dontIndentStates: ["comment"],
    lineComment: "//"
  }
});

CodeMirror.extendMode("simplemode", {
    newlineAfterToken: function(_type, content) {
      return /(^[,:]$|^\)[^,]$|^\=\($|^===$)/.test(content);
    }
  });

var elem = document.getElementById('pad');
var cm = CodeMirror.fromTextArea(elem, {
    lineNumbers: true,
  mode: "simplemode"
});
var errorLine = 0;


function autoFormatSelection() {
        var range = { from: cm.getCursor(true), to: cm.getCursor(false) };
        cm.autoFormatRange(range.from, range.to);
      }

function checkSyntax() {
  $("#message").html("");
  cm.removeLineClass(errorLine, "background", null);
  var expression = cm.getValue();
  console.log(expression);
  $.ajax({
  	type: "POST",
  	url: "http://localhost:8184/check",
  	data: {"expression": expression},
  	success: function(data) {
  		console.log(data);
  		if(data.status == "ok")
  			$("#message").html("Syntax ok!");
  		else {
  			$("#message").html(data.cause);
  			cm.addLineClass(data.line - 1, "background", "syntax-error");
  			errorLine = data.line - 1;
  			cm.scrollIntoView({"line": data.line - 1, "ch": data.pos});
  		}
  	}
  });
  
}

function diagram() {
  var expression = cm.getValue();
  $.ajax({
  	type: "POST",
  	url: "http://localhost:8184/svg",
  	data: {"expression": expression},
  	success: function(data) {
  		console.log(data);
  		var svgNode = $("svg", data);
	    var docNode = document.adoptNode(svgNode[0]);
	    var pageNode = $("#diagram");

	    pageNode.html(docNode);
  	}
  });
}


var s = new BCSocket(null, {reconnect: true});
var sjs = new window.sharejs.Connection(s);

console.log(location.hash);

var doc = sjs.get('users', location.hash);

doc.subscribe();
doc.whenReady(function () {
  if (!doc.type) doc.create('text');
  if (doc.type && doc.type.name === 'text') {
    doc.attachCodeMirror(cm);
  }
});
</script>
</body>
</html>
